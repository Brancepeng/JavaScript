
前言：

    本书就是阐述javascript语言中的精华特性，警示一些糟粕。

1.为什么要使用javascript？

    当前，除了以前主流的用于web浏览器，现在也用于服务端（node.js）,非常流行。它与web的结合，是的很流行。但是
    浏览器的API和文档对象模型（DOM）很糟糕。其实，在任何语言中处理DOM都是一件很痛苦的事情，它的规范定制的很
    拙劣并且实现互不一致。

    注：本书很少涉DOM，我认为写一本DOM的精华的书几乎是一件不可能的事情。。。

    javascript令人惊讶的是：在没有对这门语言有太多了解的情况下，也能很好的工作。当然当你知道要做什么时，他会表现的
    更好。编程是件很严谨的事情，绝不应该在懵懵懂懂的状态下开始你的工作。

    javascript建立在一些优秀的想法和糟糕的想法之上。

    那些优秀的想法包括函数，弱类型，动态对象和富有表现力的对象字面量表示法。那些糟糕的想法包括基于全局变量的的编程
    模型。

    重点：javascript的函数是主要基于词法作用域的顶级对象。
    注：什么是javascript中的顶级对象？
    首先，概述几个js中的概念。
    在理解这个问题之前，假设你已经了解了闭包，执行环境，作用域，以及function引用类型的相关知识。
    变量对象：即执行环境中包含了所有的变量和函数的对象。另外变量对象是后台的，是保存在内存中的，代码无法直接访问。

    假设在全局环境下定义函数pub()和变量pubvar:
    1.var pubvar = 1;
    2.function pub () {
    3.  var pravar = 2;
    4.  return pubvar + pravar;
    5.}

    6.alert(pub(2));     //调用pub()函数
    在执行上面这段代码的时候，后台会创建一个作用域链（scope chain）。这个作用域包含了全局对象的变量对象和并被保存在pub（）函数内部的scope
    属性中。但是在我们打开浏览器的时候已经存在了一个全局的执行环境，这个全局的执行环境属于浏览器，JS里面浏览器
    被称为window对象，我呢吧这个环境叫做A环境，只要没有关闭浏览器，环境就一直存在。
    下面会提到什么时候执行环境会被创建：
    如上代码：在程序执行到第五行时，
    我们用色块表示执行环境，链条表示作用域链，作用域上半部分是活动对象区域，下半部分是变量对象区域。
    如图：images/1.jpg(images文件下1.jpg)

当执行到第6行时，先准备console.log函数的变量对象。自然就得先执行pub(2),也就是从创建console.log函数的执行环境后，又
重新创建pub函数的执行环境B。所以说，执行环境如其名是在运行和执行代码的时候才存在的，所以我们把运行浏览器的时候会创建
全局的执行环境，这个时候根据pub函数的scopes属性中的作用域链把pub函数中的变量对象放到新的B环境中，作用域链也得到跟新，
如下图：imags/2.jpg

上图的虚线表示正在执行，全局变量对象此时处于作用域链的第二位，所以标号变成了1。你可能也注意到那个arguments对象，它是在函数被创建的时候就一直存在的，无需用户创建。arguments对象保存的是函数圆括号内定义的参数，准确来说保存的是参数的值，因这里我们没有设置参数，所以显示未定义。


此时我们把属于B环境的变量对象（也就是pub（）函数中的所有函数和变量）叫做活动对象。

因此我们可以说变量对象包含了活动对象，活动对象就是作用域链上正在被执行和引用的变量对象。我们从活动对象的名称中也能
看出 “执行、运行、激活” 等意味。你可以这样理解，整个代码的运行总有一个起始的对象吧，不管这个起始是变量还是函数，
总要有一个称呼，虽然我们把执行环境中的变量和函数的总称叫做变量对象，但这不能反映代码的动态性，为了区别于普通的变量
对象，我们创造了活动对象的概念。

这就完了？没有，上一段我们说到代码的动态性，所谓动态性在这里的意思是有些代码参与了运行，有些没有，就像高中的化学
反应一样，总有一些化学物不会参与到整个反应中来。我们把上面的代码变成如下：
var pubvar = 1;
function pub () {
  var pravar = 2;
  return pubvar + pravar;
}

var pubvar2 = 3;
function pub2 () {
  var pravar = 2;
  return pubvar2 + pravar;
}

alert(pub(2));      //调用pub()函数

这个时候全局作用域链和执行环境如下：images/3.jpg

接着，我们调用pub函数，执行环境和作用域链如下：images/4.jpg
你看没有被调用的pub2（）函数仍然只是闲着，甚至没有被pub（）函数在内部引用。由于pub2（）没有参与整个pub（）函数的调
用过程，所以pub2（）中不存在活动对象，只有“处于静止状态”的变量对象，当然也没有创建执行环境。

到这里就完了？也没有，我们刚才也只是讨论了两个平行且毫不关联的函数其中一个被调用的状况，言下之意就是也存在函数相互
影响的例子，最典型的就是闭包，闭包是一种函数嵌套的情况。
定义如下代码：
function returnfunc (propertyName) {
  return function (obj) {             //-----这行定义并返回了一个闭包，也被称之为一个匿名函数
    return obj[propertyName];         //这里用方括号法访问属性，因为属性是变量（returnfunc（）函数的参数）
  };
}

var savefunc = returnfunc("name");     //调用returnfunc（）
var result = savefunc({name:"Picasso"});//调用savefunc（）
alert(result);                        //返回字符串“Picasso”

上面这段代码值执行之前，会先获取函数申明和其他变量申明（出函数以外的全部为undefined）。如下图:images/5.jpg

当开始调用returnfunc时，马上会创建一个包含returnfunc()变量对象的执行环境，作用域链开始变化，如下图：images/6.jpg
图的白色虚线表示执行程序产生的效果，它可能表示的是返回一个结果、复制某种值、产生一个新物体、建立某种联系等。
题外话：你会发现上图的arguments参数的值和propertyName的值是一样的，这是因为arguments保存的就是参数，采用实时映射的方
式与参数建立联系，如果你在returnfunc（）函数内再加一个值为{name:"picasso"}，名为obj的参数，那么arguments的值变
成[{name:"nicholas"},{name:picasso}]，是的，你没看错，arguments是一个数组！！！(注意，如果你用Array.isArray()函数
检验arguments是否为array时，结果为false。也就是说，形式类似数组，但类型并不是数组。)

随后returnfunc（）函数会返回它内部的匿名函数，当匿名函数被返回后，整个作用域链和执行环境又发生了变化：如下图：images/7.jpg

我们看到匿名函数（闭包）被添加到了最作用域链的最前端，returnfunc（）的执行环境被销毁，但我们注意到returnfunc（）函数的活
动对象仍然在被引用（匿名函数仍在访问propertyName参数），因此returnfunc（）函数的变量对象仍然在内存中，成为活动对象。这
就是为什么匿名函数就能访问returnfunc（）函数定义的所有变量和全局环境定义的变量，毕竟returnfunc（）的活动对象仍然保持“
激活”状态。

根据上面所述，随着代码一行一行的被执行、执行环境不断被创建和销毁、变量对象间的各种关系被建立，这些背后的逻辑导致活动对象也
在不断变化，这足以证明活动对象只是正在被执行和引用的变量对象。

我个人的理解是：活动对象是按照状态划分的一类变量对象，你也可以根据变量对象被调用次数的多少来定义一个常用对象和闲置对象，不
过没人这么蛋疼。。。

注：函数内部都有一个叫做执行环境用于控制变量和函数的访问，函数内部所有的变量和函数都保存在一个叫做变量对象中（这部分是隐
式的），变量对象被调用的时候就称之为活动对象，变量对象里面如果还有（函数）变量对象他们之间需要访问的这个时候又被称之为作
用域链！一层层到全局执行环境！


OK，下面接着22行继续：
如今大部分编程语言都要求强类型，其原理在于强类型允许编译器在编译时检测错误。












