1.加法运算符
加法运算符（+）是最常见的运算符之一，但是使用规则却相对复杂。因为在JavaScript语言里面，这个运算符可以完成两种运算，既
可以处理算术的加法，也可以用作字符串连接，它们都写成+。
它的算法步骤如下。

如果运算子是对象，先自动转成原始类型的值（即先执行该对象的valueOf方法，如果结果还不是原始类型的值，再执行toString方法；如果对象是Date实例，则先执行toString方法）。
两个运算子都是原始类型的值以后，只要有一个运算子是字符串，则两个运算子都转为字符串，执行字符串连接运算。
否则，两个运算子都转为数值，执行加法运算。
// 加法
1 + 1 // 2
true + true // 2
1 + true // 2

// 字符串连接
'1' + '1' // "11"
'1.1' + '1.1' // "1.11.1"
下面是一些例子。

'1' + {foo: 'bar'} // "1[object Object]"
'1' + 1 // "11"
'1' + true // "1true"
'1' + [1] // "11"
上面代码中，由于运算符左边是一个字符串，导致右边的运算子都会先转为字符串，然后执行字符串连接运算
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
下面的写法，可以用来将一个值转为字符串。

x + ''
加法运算符会将其他类型的值，自动转为字符串，然后再执行连接运算。

[1, 2] + [3]
// "1,23"

// 等同于
String([1, 2]) + String([3])
// '1,2' + '3'

注意:
var now = new Date();
typeof (now + 1) // "string"
typeof (now - 1) // "number"

严格相等运算符

1.不同类型的值:如果两个值的类型不同，直接返回false。
1 === "1" // false
true === "true" // false
上面代码比较数值的1与字符串的“1”、布尔值的true与字符串“true”，因为类型不同，结果都是false。
同一类的原始类型值:同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。
1 === 0x1 // true
上面代码比较十进制的1与十六进制的1，因为类型和值都相同，返回true。

需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。
NaN === NaN  // false
+0 === -0 // true

同一类的复合类型值:
两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。

{} === {} // false
[] === [] // false
(function (){} === function (){}) // false

上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，
它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false。

如果两个变量引用同一个对象，则它们相等。

var v1 = {};
var v2 = v1;
v1 === v2 // true

注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。

new Date() > new Date() // false
new Date() < new Date() // false
new Date() === new Date() // false

上面的三个表达式，前两个比较的是值，最后一个比较的是地址，所以都返回false

（4）undefined 和 null

undefined和null与自身严格相等。

undefined === undefined // true
null === null // true

由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。

var v1;
var v2;
v1 === v2 // true

严格不相等运算符

严格相等运算符有一个对应的“严格不相等运算符”（!==），两者的运算结果正好相反。

1 !== '1' // true

且运算符 &&

且运算符的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；
如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。

var x = 1;
(1 - 1) && ( x += 1) // 0
x // 1
上面代码的最后一部分表示，由于且运算符的第一个运算子的布尔值为false，则直接返回它的值0，而
不再对第二个运算子求值，所以变量x的值没变。

这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写。

if (i) {
  doSomething();
}

// 等价于

i && doSomething();

上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。

且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。

true && 'foo' && '' && 4 && 'foo' && true
// ''

或运算符 ||

或运算符（||）的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；
如果第一个运算子的布尔值为false，则返回第二个运算子的值。
或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。

false || 0 || '' || 4 || 'foo' || true
// 4
上面代码中第一个布尔值为true的表达式是第四个表达式，所以得到数值4。

4.三目条件运算
三元条件运算符用问号（?）和冒号（:），分隔三个表达式。如果第一个表达式的布尔值为true，则返回第二个表达式的值，
否则返回第三个表达式的值。

't' ? 'hello' : 'world' // "hello"
0 ? 'hello' : 'world' // "world"

上面代码的t和0的布尔值分别为true和false，所以分别返回第二个和第三个表达式的值。

通常来说，三元条件表达式与if...else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别
，if...else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用
三元条件表达式，而不能使用if..else。
console.log(true ? 'T' : 'F');
上面代码中，console.log方法的参数必须是一个表达式，这时就只能使用三元条件表达式。
如果要用if...else语句，就必须改变整个代码写法了。

其他运算符:
void运算符
void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。

void 0 // undefined
void(0) // undefined
上面是void运算符的两种写法，都正确。建议采用后一种形式，即总是使用括号。因为void运算符的优先性很高，
如果不使用括号，容易造成错误的结果。比如，void 4 + 7实际上等同于(void 4) + 7。

这个运算符主要是用于书签工具（bookmarklet），以及用于在超级链接中插入代码，目的是返回undefined可以防止网页跳转。

<a href="javascript:void window.open('http://example.com/')">
  点击打开新窗口
</a>

上面代码用于在网页中创建一个链接，点击后会打开一个新窗口。如果没有void，点击后就会在当前窗口打开链接。

下面的代码会提交表单，但是不会产生页面跳转。

<a href="javascript: void(document.form.submit())">
文字</a>

逗号运算符:
逗号运算符用于对两个表达式求值，并返回后一个表达式的值。

'a', 'b' // "b"

var x = 0;
var y = (x++, 10);
x // 1
y // 10

